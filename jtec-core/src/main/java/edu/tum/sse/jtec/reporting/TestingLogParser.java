package edu.tum.sse.jtec.reporting;

import edu.tum.sse.jtec.instrumentation.testevent.TestTracingEvent;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public final class TestingLogParser {

    /**
     * Matches the pattern of the test log generated by JTec:
     * Timestamp PID TestEvent [TestSuite] [TestCaseName/Testresults]
     */
    private final Pattern testEventRegex = Pattern.compile("^(\\d+) (\\d+) (\\w+) ?(.*)$");
    private final boolean isForkingMode;

    public TestingLogParser(boolean isForkingMode) {
        this.isForkingMode = isForkingMode;
    }

    public Map<String, List<TestSuite>> parse(final Path testLog) throws IOException {
        Map<String, List<TestSuite>> testSuites = new HashMap<>();
        final String[] parts = testLog.getFileName().toString().split("_");
        final long globalStartTimestamp = Long.parseLong(parts[1]);
        boolean firstTestSuite = true;
        boolean insideTestSuite = false;
        TestSuite currentTestSuite = new TestSuite();
        TestSuite lastTestSuite = null;
        for (String line : Files.readAllLines(testLog)) {
            final Matcher matcher = testEventRegex.matcher(line);
            if (matcher.matches()) {
                final MatchResult result = matcher.toMatchResult();
                final long timestamp = Long.parseLong(result.group(1));
                final String testSuitePid = result.group(2);
                final TestTracingEvent event = TestTracingEvent.valueOf(result.group(3));

                switch (event) {
                    case TEST_FINISHED:
                    case TEST_STARTED:
                        // Relevant for handling individual test cases later.
                        break;
                    case SUITE_STARTED:
                        currentTestSuite = new TestSuite();
                        currentTestSuite.setStartTimestamp(timestamp);
                        insideTestSuite = true;
                        break;
                    case SUITE_FINISHED:
                        // We need to deal with the case that the SUITE_FINISHED event is triggered multiple times for the same test suite.
                        // In those cases, we simply use the last seen test suite in the log (if available).
                        if (!insideTestSuite && lastTestSuite != null) {
                            currentTestSuite = lastTestSuite;
                            currentTestSuite.setDuration(currentTestSuite.getDuration() + (timestamp - currentTestSuite.getEndTimestamp()));
                            currentTestSuite.setEndTimestamp(timestamp);
                        } else {
                            currentTestSuite.setEndTimestamp(timestamp);
                            currentTestSuite.getSpawnedProcesses().add(testSuitePid);
                            currentTestSuite.setDuration(currentTestSuite.getEndTimestamp() - currentTestSuite.getStartTimestamp());
                        }
                        // In case we are in forking mode, we want all events before the first test suite
                        // to be accounted for the first test suite and therefore override the start timestamp.
                        if (isForkingMode && firstTestSuite) {
                            currentTestSuite.setStartTimestamp(globalStartTimestamp);
                        }
                        firstTestSuite = false;

                        // Parse details of test suite end event.
                        String[] eventDetailParts = result.group(4).split(" ");
                        final String currentTestId = eventDetailParts[0];
                        currentTestSuite.setTestId(currentTestId);
                        currentTestSuite.setRunCount(Integer.parseInt(eventDetailParts[1]));
                        currentTestSuite.setFailureCount(Integer.parseInt(eventDetailParts[2]));
                        currentTestSuite.setIgnoreCount(Integer.parseInt(eventDetailParts[3]));

                        // Add test suite to map (only if this is the first found SUITE_FINISHED event).
                        if (insideTestSuite) {
                            testSuites.putIfAbsent(testSuitePid, new ArrayList<>());

                            // It may happen that a test suite is listed twice in the test log.
                            // In those cases, we simply update the already existing test suite entry.
                            Optional<TestSuite> maybeExistingTestSuite = testSuites.get(testSuitePid)
                                    .stream()
                                    .filter((ts) -> ts.getTestId().equals(currentTestId))
                                    .findFirst();
                            if (maybeExistingTestSuite.isPresent()) {
                                final TestSuite existingTestSuite = maybeExistingTestSuite.get();
                                existingTestSuite.setDuration(existingTestSuite.getDuration() + currentTestSuite.getDuration());
                                existingTestSuite.setEndTimestamp(currentTestSuite.getEndTimestamp());
                                existingTestSuite.setRunCount(currentTestSuite.getRunCount());
                                existingTestSuite.setFailureCount(currentTestSuite.getFailureCount());
                                existingTestSuite.setIgnoreCount(currentTestSuite.getIgnoreCount());
                                currentTestSuite = existingTestSuite;
                            } else {
                                testSuites.get(testSuitePid).add(currentTestSuite);
                            }
                        }
                        lastTestSuite = currentTestSuite;
                        currentTestSuite = new TestSuite();
                        insideTestSuite = false;
                        break;
                }
            }
        }
        return testSuites;
    }

}
