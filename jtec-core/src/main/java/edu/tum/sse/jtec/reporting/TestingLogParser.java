package edu.tum.sse.jtec.reporting;

import edu.tum.sse.jtec.instrumentation.testevent.TestTracingEvent;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public final class TestingLogParser {

    /**
     * Matches the pattern of the test log generated by JTec:
     * Timestamp PID TestEvent [TestSuite] [TestCaseName/Testresults]
     */
    private final Pattern testEventRegex = Pattern.compile("^(\\d+) (\\d+) (\\w+) ?(.*)$");
    private final boolean isForkingMode;

    public TestingLogParser(boolean isForkingMode) {
        this.isForkingMode = isForkingMode;
    }

    public Map<String, List<TestSuite>> parse(final Path testLog) throws IOException {
        Map<String, List<TestSuite>> testSuites = new HashMap<>();
        final String[] parts = testLog.getFileName().toString().split("_");
        final long globalStartTimestamp = Long.parseLong(parts[1]);
        boolean firstTestSuite = true;
        TestSuite currentTestSuite = new TestSuite();
        for (String line: Files.readAllLines(testLog)) {
            final Matcher matcher = testEventRegex.matcher(line);
            if (matcher.matches()) {
                final MatchResult result = matcher.toMatchResult();
                final long timestamp = Long.parseLong(result.group(1));
                final String testSuitePid = result.group(2);
                final TestTracingEvent event = TestTracingEvent.valueOf(result.group(3));

                switch (event) {
                    case TEST_FINISHED:
                    case TEST_STARTED:
                        // Relevant for handling individual test cases later.
                        break;
                    case SUITE_STARTED:
                        currentTestSuite = new TestSuite();
                        currentTestSuite.setStartTimestamp(timestamp);
                        break;
                    case SUITE_FINISHED:
                        currentTestSuite.setEndTimestamp(timestamp);
                        currentTestSuite.getSpawnedProcesses().add(testSuitePid);
                        currentTestSuite.setDuration(currentTestSuite.getEndTimestamp() - currentTestSuite.getStartTimestamp());
                        // In case we are in forking mode, we want all events before the first test suite
                        // to be accounted for the first test suite and therefore override the start timestamp.
                        if (isForkingMode && firstTestSuite) {
                            currentTestSuite.setStartTimestamp(globalStartTimestamp);
                        }
                        firstTestSuite = false;

                        // Parse details of test suite end event.
                        String[] eventDetailParts = result.group(4).split(" ");
                        currentTestSuite.setTestId(eventDetailParts[0]);
                        currentTestSuite.setPassed(Integer.parseInt(eventDetailParts[1]));
                        currentTestSuite.setFailed(Integer.parseInt(eventDetailParts[2]));
                        currentTestSuite.setIgnored(Integer.parseInt(eventDetailParts[3]));

                        // Add test suite to map.
                        testSuites.putIfAbsent(testSuitePid, new ArrayList<>());
                        testSuites.get(testSuitePid).add(currentTestSuite);
                        currentTestSuite = new TestSuite();
                        break;
                }
            }
        }
        return testSuites;
    }

}
